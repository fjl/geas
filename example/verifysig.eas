;;; EIP-191 personal_sign signature verification contract.
;;;
;;; Calldata format:
;;;   r (32 bytes) || s (32 bytes) || v (1 byte) || message (remaining bytes)
;;;
;;; Returns:
;;;   1 if signature matches EXPECTED_SIGNER, 0 otherwise (1 byte)

#pragma target "constantinople"

;;; Expected signer address (key is in testdata/testkey.json)
#define EXPECTED_SIGNER = address(0x3aE361814293b859D2123215ca4f38A8bB374168)

;;; Memory layout:

#define p_ecrecoverInput = 256
#define p_ecrecoverOutput = 384

;;; -----------------------------------------------------------------------------
;;; PROGRAM START --------------------------------------------------------------

    ;; Store prefix at memory[0]
    push len(prefix)            ; [size]
    push @prefix                ; [codeOffset, size]
    push 0                      ; [memDest, codeOffset, size]
    codecopy                    ; []

    ;; Calculate message length = calldatasize - 65
    calldatasize                ; [cdsize]
    push 65                     ; [65, cdsize]
    swap1                       ; [cdsize, 65]
    sub                         ; [msgLen]

    ;; Validate: msgLen must be > 0
    dup1                        ; [msgLen, msgLen]
    iszero                      ; [msgLen==0, msgLen]
    jumpi @fail                 ; [msgLen]

;;; Count how many decimal digits are needed for msgLen

    dup1                        ; [msgLen, msgLen]
    push 0                      ; [count=0, msgLen, msgLen]

countLoop:
    swap1                       ; [val, count, msgLen]
    push 10                     ; [10, val, count, msgLen]
    swap1                       ; [val, 10, count, msgLen]
    div                         ; [val/10, count, msgLen]
    swap1                       ; [count, val/10, msgLen]
    push 1                      ; [1, count, val/10, msgLen]
    add                         ; [count+1, val/10, msgLen]
    dup2                        ; [val/10, count+1, val/10, msgLen]
    jumpi @countLoop            ; [count+1, val/10, msgLen]

    swap1                       ; [val/10, digitCount, msgLen]
    pop                         ; [digitCount, msgLen]

;;; Write decimal digits (right to left)

    ;; Calculate rightmost write position = len(prefix) - 1 + digitCount
    dup2                        ; [msgLen, digitCount, msgLen]
    dup2                        ; [digitCount, msgLen, digitCount, msgLen]
    push len(prefix) - 1        ; [plen, digitCount, msgLen, digitCount, msgLen]
    add                         ; [writePos, msgLen, digitCount, msgLen]

writeLoop:
    ;; Stack: [writePos, remaining, digitCount, msgLen]
    swap1                       ; [remaining, writePos, digitCount, msgLen]
    dup1                        ; [remaining, remaining, writePos, ...]
    push 10                     ; [10, remaining, remaining, writePos, ...]
    swap1                       ; [remaining, 10, remaining, writePos, ...]
    mod                         ; [digit, remaining, writePos, ...]
    push "0"                    ; [48, digit, remaining, writePos, ...]
    add                         ; [ascii, remaining, writePos, ...]
    dup3                        ; [writePos, ascii, remaining, writePos, ...]
    mstore8                     ; [remaining, writePos, ...]

    ;; Divide remaining by 10
    push 10                     ; [10, remaining, writePos, ...]
    swap1                       ; [remaining, 10, writePos, ...]
    div                         ; [remaining/10, writePos, digitCount, msgLen]

    ;; Decrement write position
    swap1                       ; [writePos, remaining/10, digitCount, msgLen]
    push 1                      ; [1, writePos, remaining/10, ...]
    swap1                       ; [writePos, 1, remaining/10, ...]
    sub                         ; [writePos-1, remaining/10, digitCount, msgLen]

    ;; Continue if remaining > 0
    dup2                        ; [remaining/10, writePos-1, remaining/10, ...]
    jumpi @writeLoop            ; Continue if not zero

    pop                         ; [remaining/10, digitCount, msgLen]
    pop                         ; [digitCount, msgLen]

;;; Copy message from calldata[65] to memory[len(prefix) + digitCount]

    swap1                       ; [msgLen, digitCount]
    dup1                        ; [msgLen, msgLen, digitCount]
    push 65                     ; [65, msgLen, msgLen, digitCount]
    dup4                        ; [digitCount, 65, msgLen, msgLen, digitCount]
    push len(prefix)            ; [prefixLen, digitCount, 65, msgLen, msgLen, digitCount]
    add                         ; [destOffset, 65, msgLen, msgLen, digitCount]
    calldatacopy                ; [msgLen, digitCount]

;;; Hash the EIP-191 message

    push len(prefix)            ; [prefixLen, msgLen, digitCount]
    add                         ; [prefixLen+msgLen, digitCount]
    add                         ; [totalLen]
    push 0                      ; [offset, totalLen]
    keccak256                   ; [hash]

;;; Prepare ecrecover input

    ;; Store hash at ecrecoverInput location
    push p_ecrecoverInput       ; [loc, hash]
    mstore                      ; []

    ;; Load v from calldata[64], extract high byte and add 27 to match
    ;; Ethereum signature format.
    push 64                     ; [64]
    calldataload                ; [word]
    push 248                    ; [248, word]
    shr                         ; [v]
    push 27                     ; [27, v]
    add                         ; [v+27]
    push p_ecrecoverInput + 32  ; [loc, v]
    mstore                      ; []

    ;; Load r from calldata[0]
    push 0                      ; [0]
    calldataload                ; [r]
    push p_ecrecoverInput + 64  ; [loc, r]
    mstore                      ; []

    ;; Load s from calldata[32]
    push 32                     ; [32]
    calldataload                ; [s]
    push p_ecrecoverInput + 96  ; [loc, s]
    mstore                      ; []

;;; Call ECRECOVER

    push 32                     ; [outSize]
    push p_ecrecoverOutput      ; [outOffset, outSize]
    push 128                    ; [inSize, outOffset, outSize]
    push p_ecrecoverInput       ; [inOffset, inSize, outOffset, outSize]
    push 1                      ; [addr, inOffset, inSize, outOffset, outSize]
    gas                         ; [gas, addr, inOffset, inSize, outOffset, outSize]
    staticcall                  ; [success]

    ;; Check if call succeeded
    iszero                      ; [failed]
    jumpi @fail                 ; []

;;; Compare recovered address and return

    push p_ecrecoverOutput      ; [loc]
    mload                       ; [recovered]
    push EXPECTED_SIGNER        ; [expected, recovered]
    eq                          ; [match]
    jumpi @success              ; []

fail:
    ;; Return 0x00 (failure, 1 byte)
    push 0                      ; [0]
    push 0                      ; [offset, 0]
    mstore8                     ; []
    push 1                      ; [size]
    push 0                      ; [offset, size]
    return                      ; []

success:
    ;; Return 0x01 (success, 1 byte)
    push 1                      ; [1]
    push 0                      ; [offset, 1]
    mstore8                     ; []
    push 1                      ; [size]
    push 0                      ; [offset, size]
    return                      ; []

;;; -----------------------------------------------------------------------------
;;; DATA -----------------------------------------------------------------------

#bytes prefix: "\x19Ethereum Signed Message:\n"
